
# Лабораторная работа №1. Реализовать алгоритм линейного поиска в массиве с барьером

``` c++
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;
const int arrSize = 20;

int main()
{
	setlocale(LC_ALL, "rus");
	int arr[arrSize], desiredValue, i;
	int minDiaposon = 0, maxDiaposon = 20;
	int desiredIndex = -1;

	cout << "Введите искомое число: ";
	cin >> desiredValue;

	cout << endl << "Массив:" << endl;
	srand(time(0));
	//Заполняю массив случайными числами:
	for (i = 0; i < arrSize; i++)
	{
		arr[i] = minDiaposon + rand() % (maxDiaposon - minDiaposon + 1);
		//Последнему элементу массива присваиваю искомое значение(барьер):
		if (i == (arrSize - 1))
		{
			arr[i] = desiredValue;
		}
		//Вывожу элементы массива на экран:
		cout << arr[i] << " ";
	}

	//Выполняю поиск:
	for (i = 0; i < arrSize; i++)
	{
		if (arr[i] == desiredValue)
	    {
		    desiredIndex = i;
			break;
		}
	}

	cout << endl << endl << "Индекс искомого числа: " << desiredIndex;
}
```

## Ответы на вопросы

- Алгоритм линейного поиска:
Начиная с первого, все элементы массива последовательно просматриваются и сравниваются с искомым. Если на каком-то шаге текущий элемент окажется равным искомому, тогда элемент считается найденным, и в качестве результата возвращается номер этого элемента, либо другая информация о нем. Далее, в качестве выходных данных будет выступать номер элемента. Иначе, следуют возвратить что-то, что может оповестить о его отсутствии в пройденной последовательности. Имеется вероятность наличия нескольких элементов с одинаковыми значениями, совпадающими со значением ключа. В таком случае, если нет конкретных условий, можно, например, за результирующий взять номер первого найденного элемента, или записать в массив номера всех тождественных элементов.

- Алгоритм линейного поиска с барьером:
Этот алгоритм является модификацией линейного поиска. В конец массива добавляется элемент, который нужно найти (либо заместо последнего). Теперь мы можем пройтись циклом не по всем элементам массива, а до того момента, когда будет найден нужный элемент. Таким образом, среднее время выполнения алгоритма линейного поиска с барьером становится ниже, чем у обычного линейного поиска.

- Алгоритм двоичного поиска:
В отличие от линейного поиска, бинарный поиск использует отсортированный список. Для поиска значения вы сначала сравниваете значение со средним элементом списка. Если они равны, значение поиска найдено. Если значение поиска больше, чем средний элемент, выполняется поиск в верхней половине данных. Затем вы сравниваете средний элемент этого раздела со значением поиска. В качестве альтернативы, если элемент меньше среднего элемента, вы ищете в нижней половине списка и сравниваете его среднее значение. Список многократно делится пополам до тех пор, пока элемент не будет найден или не останется элементов для поиска.

- Где используются вышеописанные алгоритмы поиска:
Недостатком алгоритма линейного поиска является то, что в худшем случае осуществляется просмотр всего массива, что занимает много времени. Поэтому данный алгоритм используется, если множество содержит небольшое количество элементов. Лучше использовать его новичкам для решения их первых задач. 
Поиск с барьером работает быстрее, но временная сложность алгоритма остается такой же.
Метод двоичного поиска используется в качестве быстрого варианта поиска в заранее отсортированном массиве.

