# Отчет по лабораторной работе №3

Выполнила студентка группы ИСТбд-22 Ушкова Александра

Исходный код

```C++
#include <iomanip>
#include <iostream>

using namespace std;

int QuickSort(int *array,int left,int right)
{
    long base, opposite, p;
    int c;
    base=left;
    opposite=right;
    while (base!=opposite)
    {
        if((array[base]>array[opposite])^(base>opposite))
        {
            c=array[base];
            array[base]=array[opposite];
            array[opposite]=c;

            p=base;
            base=opposite;
            if(p<opposite)
            opposite=p+1;
            else
            opposite=p-1;
        }
        else
        {
            if (base<opposite)
            opposite--;
            else opposite++;
        }
    }

    if (left<base-1) QuickSort(array,left,base-1);
    if (base+1<right) QuickSort(array,base+1,right);
}

void Raspechatka (int cout, int array[])
{
    for(int i=0; i<cout; ++i)
    cout << array[i] << ' ';
}

int main()
{

  int i = 8;
  int array[i]={9,6,3,4,10,8,2,7};
  cout<<" Sourse array "<<endl;
  for(i=0; i<8; ++i)
  cout << array[i] << ' ';
  QuickSort(array,0,7);
  cout<<"\n";
  cout<<"\n Sorted array"<<endl;
  for(i=0; i<8; ++i)
  cout<<array[i]<<' ';
  cout<<"\n";



}
```

Ответы на вопросы.

Сэр Чарльз Энтони Ричард Хоар (11 января 1934) — английский учёный, специализирующийся в области информатики и вычислительной техники. Наиболее известен как разработчик алгоритма «быстрой сортировки» (1960), на сегодняшний день являющегося наиболее популярным алгоритмом сортировки.

QuickSort является существенно улучшенным вариантом алгоритма сортировки с помощью прямого обмена, известного в том числе своей низкой эффективностью. Принципиальное отличие состоит в том, что в первую очередь производятся перестановки на наибольшем возможном расстоянии и после каждого прохода элементы делятся на две независимые группы.

Общая идея алгоритма состоит в следующем:

1)Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность (см. ниже).
2)Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующих друг за другом: «элементы меньшие опорного», «равные» и «большие»[1].
3)Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.

Быстрая сортировка относится к алгоритмам «разделяй и властвуй».

Алгоритм состоит из трёх шагов:

1.Выбрать элемент из массива. Назовём его опорным.
2.Разбиение: перераспределение элементов в массиве таким образом, что элементы меньше опорного помещаются перед ним, а больше или равные после.
3.Рекурсивно применить первые два шага к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один элемент или отсутствуют элементы.

Выбор опорного пункта. В ранних реализациях, как правило, опорным выбирался первый элемент, что снижало производительность на отсортированных массивах. Для улучшения эффективности может выбираться средний, случайный элемент или (для больших массивов) медиана первого, среднего и последнего элементов.Медиана всей последовательности является оптимальным опорным элементом, но её вычисление слишком трудоёмко для использования в сортировке.

Разбиение Ломуто. Данный алгоритм разбиения был предложен Нико Ломуто.В данном примере опорным выбирается последний элемент. Алгоритм хранит индекс в переменной i. Каждый раз, когда находится элемент, меньше или равный опорному, индекс увеличивается, и элемент вставляется перед опорным. Хоть эта схема разбиения проще и компактнее, чем схема Хоара, она менее эффективна и используется в обучающих материалах.

algorithm partition(A, low, high) is
    pivot := A[high]
    i := low
    for j := low to high - 1 do
        if A[j] ≤ pivot then
            swap A[i] with A[j]
            i := i + 1
    swap A[i] with A[high]
    return i

Разбиение Хоара. Данная схема использует два индекса (один в начале массива, другой в конце), которые приближаются друг к другу, пока не найдётся пара элементов, где один больше опорного и расположен перед ним, а второй меньше и расположен после. Эти элементы меняются местами. Обмен происходит до тех пор, пока индексы не пересекутся. Алгоритм возвращает последний индекс. Схема Хоара эффективнее схемы Ломуто, так как происходит в среднем в три раза меньше обменов элементов, и разбиение эффективнее, даже когда все элементы равны.

Достоинства и недостатки

Достоинства:
*Один из самых быстродействующих (на практике) из алгоритмов внутренней сортировки общего назначения.
*Алгоритм очень короткий: запомнив основные моменты, его легко написать «из головы».
*Требует лишь О(log n) дополнительной памяти для своей работы.
*Работает на связных списках и других структурах с последовательным доступом, допускающих эффективный проход как от начала к концу, так и от конца к началу.

Недостатки:
*Сильно деградирует по скорости (до O(n^2)) в худшем или близком к нему случае, что может случиться при неудачных входных данных.
*Прямая реализация в виде функции с двумя рекурсивными вызовами может привести к ошибке переполнения стека, так как в худшем случае ей может потребоваться сделать O(n) вложенных рекурсивных вызовов.
*Неустойчив.
