# Лабораторная работа №4

## Пирамидальная сортировка:

### Исходный код:

```c++
#include <iostream>
#include <math.h>
using namespace std;
void HeapSort(int* arr, int k) {
	for ( k; k >= 2; k--)
	{
		for (int i = k; i >= 2; i--)
		{
			if (i % 2 == 1)
			{
				if (arr[i - 1] < arr[(i - 1) / 2 - 1])
				{
					int tmp = arr[i - 1];
					arr[i - 1] = arr[(i - 1) / 2 - 1];
					arr[(i - 1) / 2 - 1] = tmp;
				}
			}
			else
			{
				if (arr[i - 1] < arr[i / 2 - 1])
				{
					int tmp = arr[i - 1];
					arr[i - 1] = arr[i / 2 - 1];
					arr[i / 2 - 1] = tmp;
				}
			}
		}
		int tmp = arr[k-1];
		arr[k - 1] = arr[0];
		arr[0] = tmp;

	}
	return;
}

int main() {
	int n;
	cout << "enter the size of the array:" << endl;
	cin >> n;
	int* arr = new int[n];
	cout << "enter the array elements:" << endl;
	for (int i = 0; i < n; i++)
	{
		int digit;
		cin >> digit;
		arr[i] = digit;
	}
	HeapSort(arr, n);
	
	cout << "result: ";
	for (int j = 0; j < n; j++)
	{
		cout << arr[j] << " ";
	}
	cout << endl;
	system("pause");
	return 0;
}
```

### Ответы на вопросы:

1. Бинарное сортирующее дерево – это бинарное дерево, для которого выполняются следующие дополнительные условия (свойства дерева поиска):

* оба поддерева – левое и правое, являются двоичными деревьями поиска;
* у всех узлов левого поддерева произвольного узла X значения ключей данных меньше, чем значение ключа данных самого узла X;
* у всех узлов правого поддерева произвольного узла X значения ключей данных не меньше, чем значение ключа данных узла X.
* данные в каждом узле должны обладать ключами, на которых определена операция сравнения меньше.

2. Последовательно, начиная с последнего уровня пирамиды, анализируем элементы, сравнивая их с родительскими. Если дочерний элемент меньше родительского, то они обмениваются значениями. После первого цикла на корневой позиции окажется наименьшее число. Присваиваем это значение последнему элементу пирамиды и на следующем цикле начинаем работу с n-1 индекса. 

3. * неустойчивая сортировка не может работать с большими объемами данных из-за угрозы переполнения стека
   * устойчивая сортировка не меняет "местами" эквивалентные элементы
   * устойчивая сортировка "ошибается" реже, отсюда и название
   * устойчивая сортировка имеет постоянную вычислительную сложность (О(n)), в то время как неустойчивая варьируется в зависимости от исходных данных.
   Пирамидальная сортировка относится к неустойчивым

4. `+` худшее время работы — O(nlogn)

   `+` требует O(1) дополнительной памяти.

   `-` Ал­го­ритм от­но­си­тель­но мед­лен­но ра­бо­та­ет, ко­гда чис­ло сор­ти­руе­мых эле­мен­тов мень­ше сот­ни.

   `-` Ко­гда ко­ли­че­ство сор­ти­руе­мых дан­ных на­чи­на­ет пре­вы­шать раз­мер кэ­ша (в на­шем слу­чае мил­ли­он чи­сел по 4 бай­та, ско­рость сор­ти­ров­ки па­да­ет.

   `-` неустойчивая

   `-`на почти отсортированных данных работает столь же долго, как и на хаотических данных.