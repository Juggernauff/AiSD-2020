# Лабораторная работа №2

## Вариант №3 - Метод перебора

### Исходный код

```c++
#include <iostream>
#include <limits>
using namespace std;
void MethodSearch(int *x, int k) {
	for (int j = 0; j < k; j++) {
		int min = x[j], index = j;
		for (int i = j+1; i < k; i++) {
			if (x[i] < min) {
				min = x[i];
				index = i;
			}
		}
		x[index] = x[j];
		x[j] = min;
	}
}
int main() {
	int n;
	cout << "Enter the size of the array:" << endl;
	cin >> n;
	int* arr = new int[n];
	cout << "Enter the array elements:" << endl;
	for (int i = 0; i < n; i++)
	{
		int digit;
		cin >> digit;
		arr[i] = digit;
	}
	 MethodSearch(arr, n);
	 cout << "Result: ";
	 for (int j = 0; j < n; j++)
	 {
		 cout << arr[j] << " ";
	 }
	 cout << endl;
	 system("pause");
	return 0;
}
```

### Ответы на вопросы

1. Суть алгоритма пузырька состоит в повторяющихся проходах по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает – массив отсортирован. При проходе алгоритма элемент, стоящий не на своём месте, "всплывает" до нужной позиции.

Принцип работы пузырьковой сортировки можно описать в три пункта:

    1. Прохождение по всему массиву;
    2. Сравнивание между собой пар соседних ячеек;
    3. Если при сравнении оказывается, что значение ячейки i больше, чем значение ячейки i + 1, то мы меняем значения этих ячеек местами;

2. `+` не требуется дополнительных массивов

   `-` неупорядоченные элементы в начале массива поднимаются на свои места очень медленно. Время работы алгоритма пропорционально квадрату количества элементов (самый медленный способ сортировки)

3. Шейкер-сортировка - разновидность пузырьковой сортировки, где поочередно меняются направления сортировки. Благодаря такому подходу элементы, которые далеко находятся от своих отсортированных позиций, быстро занимают свои правильные места.

4. `+`
   * внутренние циклы проходят по массиву то в одну, то в другую сторону, поднимая самый легкий элемент вверх и опуская самый тяжелый элемент в самый низ за одну итерацию внешнего цикла.
   * на выполнение сортировки массива по возрастанию необходимо в два раза меньше итераций внешнего цикла по сравнению с классической “пузырьковой” сортировкой.

   `-` Для почти отсортированного массива шейкерная сортировка может оказаться намного быстрее «пузырька», но для случайно отсортированного исходного массива выигрыш обычно не сильно велик.

5. Сортировка методом перебора - это наиболее естественный алгоритм упорядочивания. При данной сортировке из массива выбирается элемент с наименьшим значением и обменивается с первым элементом. Затем из оставшихся n - 1 элементов снова выбирается элемент с наименьшим ключом и обменивается со вторым элементом, и т.д. 

Шаги алгоритма:

    1. находим минимальное значение в текущей части массива;
    2.производим обмен этого значения со значением на первой неотсортированной позиции;
    3. далее сортируем хвост массива, исключив из рассмотрения уже отсортированные элементы.

6. `+` 
простая в реализации и устойчивая

   `-`
   * она очень медленная, т.к. происходит очень много операций сравнения. Каждый из n элементов сравнивается со всеми последующими, поэтому количество сравнений ~n*n/2
   * если данные почти отсортированы (из 100тыс элементов только 10 стоят не на своих местах), то все равно время работы изменится мало, т.к. операций сравнения будет столько же

7. Сортировка вставками (Insertion Sort) — это простой алгоритм сортировки. Суть его заключается в том что, на каждом шаге алгоритма берется один из элементов массива, находится позиция для вставки и вставляется. Стоит отметить что массив из 1-го элемента считается отсортированным.

8. `+` алгоритм эффективен при работе со списками, алгоритм отлично справляется с массивами небольшого размера, может работать с последовательно поступающими данными.

   `-`
   * очень много перемещений элементов массива 

   * высокая алгоритмическая сложность N²